<!-- 
  TradingView Lightweight Charts™ 
  Copyright (с) 2025 TradingView, Inc. https://www.tradingview.com/
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- 
      charset: 문자 인코딩 
      viewport: 반응형 차트/화면 대응 
    -->
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0"
    />
    <title>{{ symbol_name }}</title>

    <!-- 
      TradingView Lightweight Charts 라이브러리
      unpkg.com 을 통해 standalone.production 버전 사용 
    -->
    <script
      type="text/javascript"
      src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"
    ></script>

    <style>
      /* 
        html, body 기본 설정 
        - 여백 제거, 100% 채우기 
        - 배경 검정색
        - 불필요한 스크롤바나 흰 여백 방지 
      */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #0f0f0f;
        overflow: hidden;
      }

      /* 차트 전체 영역을 차지하는 컨테이너 */
      #container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      /* 
        차트 위에 겹치는 좌상단 정보(심볼명, 타임프레임, 가격 데이터 등) 
        - #topInfo를 flex 컨테이너로 둬서 내부를 정렬
      */
      #topInfo .header {
        font-size: 22px; /* [심볼 타임프레임]의 글자 크기 */
        font-weight: bold;
      }

      .data {
        font-size: 14px; /* 가격/볼륨 데이터 글자 크기 */
        margin-left: 6px;
        margin-top: 3px; /* 가격 정보 부분을 살짝 아래로 내림 */
      }

      /* 가격 정보의 내부 스타일 */
      .price-label {
        margin-right: 3px; /* 라벨과 값 사이 간격 */
      }

      .price-group {
        margin-right: 4.5px; /* 정보 그룹 간격 */
      }

      /* 
        메인 지표 정보 영역 
        - 심볼/타임프레임 아래쪽에 붙을 지표값
      */
      #mainIndicatorInfo {
        width: 100%;
        margin-top: 4px;
      }

      /* 좌상단 지표값 영역을 전체적으로 세로 배치 */
      #leftInfo {
        display: flex;
        flex-direction: column;
      }

      /* 슬라이더 스타일 설정 */
      /* input 자체 기본 스타일 제거 */
      #timeSlider {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        background: transparent;
        accent-color: transparent; /* Chrome 기본 파란색 제거 */
      }

      /* Thumb 스타일 */
      #timeSlider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 120px;       /* 길이 (가로) */
        height: 10px;       /* 두께 (세로) */
        border-radius: 3px;/* 반 정도만 둥글게 */
        background: #fff;
        border: 2px solid #ccc;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        transform: translateY(2.5px);
        cursor: pointer;
      }

      #timeSlider::-moz-range-thumb {
        width: 120px;
        height: 10px;
        border-radius: 3px;
        background: #fff;
        border: 2px solid #ccc;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        transform: translateY(2.5px);
        cursor: pointer;
      }

      #timeSlider::-ms-thumb {
        width: 120px;
        height: 10px;
        border-radius: 3px;
        background: #fff;
        border: 2px solid #ccc;
        box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        transform: translateY(2.5px);
        cursor: pointer;
      }
    </style>
  </head>

  <!-- 슬라이드 바 설정 -->
  <input
    id="timeSlider"
    type="range"
    min="0"
    step="1"
    style="position:absolute; bottom:24px; z-index:1100;"
  />

  <div
    id="sliderDate"
    style="display:none;
          position:absolute;
          bottom:40px; left:0;
          transform:translateX(-50%);
          font-size:12px; color:#fff;
          background:rgba(15, 15, 15, 0.75);
          padding:2px 4px; border-radius:4px;
          pointer-events:none; z-index:1101;"
  ></div>


  <body>
    <!-- 
      메인 차트를 렌더링할 컨테이너 
      width:100%, height:100% 로 설정 
    -->
    <div
      id="container"
      style="position: absolute; width: 100%; height: 100%"
    ></div>

    <!-- 좌상단 정보 표시 DIV -->
    <div
      id="topInfo"
      style="
        position: absolute;
        top: 10px;
        left: 4px;
        display: flex;
        flex-direction: column;
        background: rgba(15, 15, 15, 0);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: sans-serif;
        line-height: 1.4;
        z-index: 1000;
      "
    >
      <!-- 
        심볼/타임프레임 + 가격(시가, 고가, 저가, 종가, 볼륨) 
      -->
      <div style="display: flex; align-items: center;">
        <div class="header" id="symbolInfo"></div>
        <div
          class="data"
          id="candleData"
          style="margin-left: 12px; margin-top: 7px;"
        ></div>
      </div>

      <!-- 메인 지표 정보 표시 영역 -->
      <div
        id="mainIndicatorInfo"
        style="margin-top: 14px; font-size: 14px;"
      ></div>
    </div>

    <script type="text/javascript">
      // ------------------------------------------------------
      // 심볼/타임프레임 표시: 상단 div의 innerText로 설정
      // 아이콘 설정
      // ------------------------------------------------------
      const symbolInfoEl = document.getElementById("symbolInfo");
      const rawSymbol = "{{ symbol_name }}";

      // “1000”, "usdt" 제거 → 소문자 변환
      const processed = rawSymbol
        .replace(/1000/gi, "")
        .replace(/usdt/gi, "")
        .toLowerCase();

      const baseUrl = "https://assets.coincap.io/assets/icons/";
      const iconUrl = `${baseUrl}${processed}@2x.png`;
      const fallbackUrl = `${baseUrl}usdt@2x.png`;

      const iconImg = new Image();
      iconImg.src = iconUrl;
      iconImg.alt = processed;

      // 크기 + 정렬 + 간격 조정
      iconImg.style.width = "30px";
      iconImg.style.height = "30px";
      iconImg.style.imageRendering = "auto";
      iconImg.style.verticalAlign = "middle";  // 글자 기준 중앙정렬
      iconImg.style.marginRight = "5px";       // 아이콘과 텍스트 사이 간격
      iconImg.style.marginBottom = "-4px";     // 살짝 아래로 내려줌
      iconImg.style.filter = "drop-shadow(0 0 1px white) drop-shadow(0 0 1px white)";

      // 아이콘 없을 때 fallback
      iconImg.onerror = () => {
        iconImg.src = fallbackUrl;
      };

      // 텍스트 요소도 span으로 감싸서 더 정교한 컨트롤 가능 (선택 사항)
      const textNode = document.createElement("span");
      textNode.innerText = ` ${rawSymbol} {{ trading_timeframe }}`;
      textNode.style.verticalAlign = "middle";

      symbolInfoEl.appendChild(iconImg);
      symbolInfoEl.appendChild(textNode);

      // 파비콘 설정
      const favicon = document.createElement("link");
      favicon.rel = "icon";
      favicon.type = "image/png";
      favicon.href = iconUrl;
      favicon.onerror = () => {
        favicon.href = fallbackUrl;
      };

      document.head.appendChild(favicon);

      // ------------------------------------------------------
      // Lightweight 차트 생성
      // ------------------------------------------------------
      chart = LightweightCharts.createChart(
        document.getElementById("container"),
        {
          layout: {
            background: { color: "#0f0f0f" }, // 차트 배경색 (검정)
            textColor: "#ffffff",             // 차트 내 텍스트 색 (흰색)
            panes: {
              separatorColor: "#2a2e39",       // 멀티 페인 구분선 (진한 회색)
              separatorHoverColor: "#334fad40" // 구분선 마우스오버 시 나타나는 반투명 파랑
            }
          },
          grid: {
            vertLines: { color: "#0f0f0f" },  // 수직선 (검정)
            horzLines: { color: "#0f0f0f" },  // 수평선 (검정)
          },
          crosshair: {
            mode: LightweightCharts.CrosshairMode.Normal, // 크로스헤어 모드
            vertLine: {
              color: "#ffffff",    // 수직 크로스헤어 라인 색상(흰색)
              labelVisible: false  // 수직 라인에 붙는 가격 라벨 표시 안 함
            },
            horzLine: {
              color: "#ffffff",                // 수평 크로스헤어 라인 색상(흰색)
              labelBackgroundColor: "#363a45", // 수평 라벨 배경색(회색)
              labelTextColor: "#ffffff",       // 수평 라벨 글자색(흰색)
            },
          },
          timeScale: {
            timeVisible: true // true로 설정 시 분봉/초봉 등 세부 시간 단위도 표시
          },
          handleScroll: {
            pressedMouseMove: true, // 마우스 드래그로 스크롤
            mouseWheel: true        // 마우스 휠로 확대/축소
          },
          handleScale: {
            axisPressedMouseMove: true, // 가격축 드래그로 스케일 조정
            mouseWheel: true,           // 마우스 휠로 스케일 조정
          }
        }
      );

      chart.priceScale("right").applyOptions({
        mode: 1 // 1: 로그 스케일
      });

      // 거래량 스케일도 동일하게 로그로 설정
      chart.priceScale("volume").applyOptions({
        mode: 1
      });

      chart.timeScale().applyOptions({
        rightOffset: 20  // 초기 화면 맨 오른쪽에 20개의 캔들 공간 확보
      });

      // 창 크기 변경 시 차트를 리사이즈 
      window.addEventListener("resize", () => {
        const contianer = document.getElementById("container");

        // 차트 크기 재조정
        chart.resize(contianer.clientWidth, contianer.clientHeight);

        // 크기 변경 후, 지표 정보 DIV 위치도 업데이트
        setTimeout(() => {
          repositionPaneLabels();
        });
      });

      // ------------------------------------------------------
      // 주기적으로 각 pane 높이 변화를 감지하여, 
      // 변화 시 pane에 표시된 지표 라벨 재배치
      // ------------------------------------------------------
      let prevPaneHeights = [];

      setInterval(() => {
        const panes = chart.panes(); // IPaneApi[] 배열 (각 페인)
        let changed = false;

        // 현재 페인 높이 배열 구하기
        const currentHeights = panes.map((p) => p.getHeight());

        // 이전 높이 배열과 길이가 다른지, 각 인덱스별 높이가 다른지 검사
        if (currentHeights.length !== prevPaneHeights.length) {
          changed = true;
        } else {
          for (let i = 0; i < currentHeights.length; i++) {
            if (currentHeights[i] !== prevPaneHeights[i]) {
              changed = true;
              break;
            }
          }
        }

        // 변화가 감지되면 재배치 함수 실행
        if (changed) {
          repositionPaneLabels();
        }

        // prevPaneHeights 갱신
        prevPaneHeights = currentHeights;
      }, 100); // 0.1초 간격으로 체크

      // ------------------------------------------------------
      //  지표 시리즈 동적 추가
      //  indicator_series_to_chart  => 메인 차트 위 오버레이 형태 지표
      //  indicator_series_to_pane   => 별도 페인 형태 지표
      // ------------------------------------------------------
      // 차트에 지표 시리즈 추가
      {{ indicator_series_to_chart }}

      // 페인에 지표 시리즈 추가
      {{ indicator_series_to_pane }}

      // ------------------------------------------------------
      // 메인 차트 높이 설정 (window 높이 * (1 - 페인 차트 비율))
      // 페인 차트 비율은 1개 25%로 시작하여 70%까지 수렴함
      // ------------------------------------------------------
      chart.panes()[0].setHeight(
        window.innerHeight * (1 - 0.25 + 0.45 * (1.0 - Math.exp(-0.237 * ({{ pane_count }} - 1)))));

      // ------------------------------------------------------
      // 각 페인의 실제 높이 총합을 구하여 
      // paneIndicatorDivs[p] 위치를 재배치하는 함수
      // ------------------------------------------------------
      function repositionPaneLabels() {
        const panes = chart.panes(); // IPaneApi[] 배열
        // pane 0은 메인 차트이므로 pane 1부터 배치
        for (let p = 1; p < panes.length; p++) {
          if (window.paneIndicatorDivs && window.paneIndicatorDivs[p]) {
            let offset = 0;
            // 0 ~ (p-1)까지 높이를 누적
            for (let i = 0; i < p; i++) {
              offset += panes[i].getHeight();
            }
            // 해당 offset을 top 값으로 설정하여 정확한 위치에 배치
            window.paneIndicatorDivs[p].style.top = offset + "px";
          }
        }
      }

      // ------------------------------------------------------
      // 캔들스틱 시리즈 생성
      // ※ 캔들스틱을 지표보다 나중에 그려야 캔들스틱이 위에 떠있게 됨
      // ------------------------------------------------------
      const precision = {{ price_precision }}; // 소수점 자리수
      const mainSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
        upColor: "#4caf50",          // 양봉(상승) 바디색
        downColor: "#f23645",        // 음봉(하락) 바디색
        borderUpColor: "#4caf50",    // 양봉 외곽색
        borderDownColor: "#f23645",  // 음봉 외곽색
        wickUpColor: "#4caf50",      // 양봉 꼬리색
        wickDownColor: "#f23645",    // 음봉 꼬리색
        priceFormat: {
          type: 'price',
          precision: precision,    
          minMove: {{ tick_size }}     
        }
      });

      // 마지막 값 라벨, 가격 라인을 차트에서 숨김
      mainSeries.applyOptions({
        lastValueVisible: false,
        priceLineVisible: false
      });

      // 템플릿으로 전달된 캔들 데이터(JSON string)를 JS 객체로 파싱
      const candleStickData = JSON.parse('{{ bar_data }}');

      // 시리즈에 데이터 세팅
      mainSeries.setData(candleStickData);

      // ------------------------------------------------------
      // 거래량 히스토그램 시리즈 추가
      // ------------------------------------------------------
      const volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
        // 가격 스케일을 "volume"으로 사용하여 차트에 항상 떠있게 함
        priceScaleId: "volume",            
        priceFormat: { type: "volume" }  // 거래량 표시 포맷 (1M, 1B 등)
      });

      // 거래량 그래프 위치: 메인 차트 하단 25%
      volumeSeries.priceScale().applyOptions({
        scaleMargins: { top: 0.75, bottom: 0 }
      });

      // 마지막 값 라벨, 가격 라인을 차트에서 숨김
      volumeSeries.applyOptions({
        lastValueVisible: false,
        priceLineVisible: false
      });

      // 거래량 데이터: 캔들 데이터와 동일한 time에 매핑, color는 양봉/음봉 구분 
      const volumeData = candleStickData.map((candle) => ({
        time: candle.time,
        value: candle.volume,
        color:
          candle.close >= candle.open ? "#08998180" : "#ef535080" // 양봉 초록, 음봉 빨강
      }));

      // 거래량 시리즈에 데이터 세팅
      volumeSeries.setData(volumeData);

      // ------------------------------------------------------
      // 캔들스틱 차트에 거래 마커 추가
      // ------------------------------------------------------
      window.customMarkers = [];
      let animationFrameId = null;
      const triangleWidth = 9;   
      const triangleHeight = 11; 

      // dash line 전용 SVG 컨테이너 생성
      if (!window.dashSvg) {
        const svgNS = "http://www.w3.org/2000/svg";
        window.dashSvg = document.createElementNS(svgNS, "svg");
        window.dashSvg.style.position = 'absolute';
        window.dashSvg.style.top = '0';
        window.dashSvg.style.left = '0';
        window.dashSvg.style.width = '100%';
        window.dashSvg.style.height = '100%';
        window.dashSvg.style.pointerEvents = 'none';
        window.dashSvg.style.zIndex = '900';
        document.getElementById('container').appendChild(window.dashSvg);
      }


      function addCustomMarker({time, marker_price, position, 
                                marker_color = '#ffffff', text = '', 
                                from_time, from_price, line_color}) {
        // 캔들 데이터를 찾아 low/high 값을 가져옴
        const idx = candleStickData.findIndex(c => c.time > time);
        let candle;
        if (idx === -1) {
          candle = candleStickData[candleStickData.length - 1];
        } else if (idx > 0) {
          candle = candleStickData[idx - 1];
        } else {
          candle = candleStickData[0];
        }
        const candleLow = candle.low;
        const candleHigh = candle.high;
        
        const svgNS = "http://www.w3.org/2000/svg";
        
        // 삼각형 요소 생성
        const triangleSvg = document.createElementNS(svgNS, "svg");
        triangleSvg.setAttribute("width", triangleWidth.toString());
        triangleSvg.setAttribute("height", triangleHeight.toString());
        triangleSvg.setAttribute("viewBox", `0 0 ${triangleWidth} ${triangleHeight}`);
        triangleSvg.style.position = 'absolute';
        triangleSvg.style.pointerEvents = 'none';
        triangleSvg.style.zIndex = '1000';
        
        const polygon = document.createElementNS(svgNS, "polygon");
        polygon.setAttribute("fill", marker_color);
        polygon.setAttribute("stroke", "black");
        polygon.setAttribute("stroke-width", "1");
        
        if (position === 'left') {
          // left 마커: 삼각형의 tip이 컨테이너 오른쪽에 위치하도록
          polygon.setAttribute("points", `${triangleWidth},5 0,0 0,${triangleHeight}`);
        } else if (position === 'right') {
          // right 마커: 삼각형의 tip이 컨테이너의 왼쪽에 위치하도록
          polygon.setAttribute("points", `0,5 ${triangleWidth},0 ${triangleWidth},${triangleHeight}`);
        }
        triangleSvg.appendChild(polygon);
        
        // 텍스트 요소 생성 
        const textDiv = document.createElement('div');
        textDiv.innerText = text;
        textDiv.style.position = 'absolute';
        textDiv.style.pointerEvents = 'none';
        textDiv.style.fontSize = '12px';
        textDiv.style.color = '#fff';
        textDiv.style.zIndex = '1000';
        textDiv.style.whiteSpace = 'pre-wrap';
        textDiv.style.textAlign = 'center';
        textDiv.style.textShadow = `-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000`;
        
        // 컨테이너에 삼각형과 텍스트 추가
        const containerEl = document.getElementById('container');
        containerEl.appendChild(triangleSvg);
        containerEl.appendChild(textDiv);
        
        // from_time, from_price, line_color 모두 지정되었으면 dash line 생성
        let dashLine = null;
        if (from_time !== undefined && from_price !== undefined && line_color !== undefined) {
          dashLine = document.createElementNS(svgNS, "line");
          dashLine.setAttribute("stroke", line_color);
          dashLine.setAttribute("stroke-dasharray", "4,2");
          dashLine.setAttribute("stroke-width", "1.5");
          // dashLine은 dashSvg에 추가
          window.dashSvg.appendChild(dashLine);
        }
        
        // 전역 마커 배열에 저장
        window.customMarkers.push({
          time, 
          marker_price, 
          position, 
          triangle: triangleSvg, 
          text: textDiv,
          candleLow: candle.low, 
          candleHigh: candle.high,
          from_time, 
          from_price,
          dashLine
        });

        repositionMarkers();
      }

      // ===================================================================
      // 리포지션 헬퍼 함수들

      // 좌표 계산: x는 marker의 time, y는 marker_price 기반 좌표
      function getMarkerCoords(m) {
        const x = chart.timeScale().timeToCoordinate(m.time);
        const y = mainSeries.priceToCoordinate(m.marker_price);
        return { x, y };
      }

      // 삼각형 좌표 설정: left, top 계산 후 적용
      function setTrianglePosition(m, x, y) {
        const left = m.position === 'left' ? x - triangleWidth : x;
        const top = y - triangleTipOffset;
        m.triangle.style.left = `${left}px`;
        m.triangle.style.top = `${top}px`;
      }

      // 경계 검사: 해당 좌표에서 삼각형이 컨테이너 안에 완전히 들어오는지 확인
      function isWithinBounds(x, y) {
        const left = x - (triangleWidth * (m.position === 'left' ? 1 : 0));
        const top = y - triangleTipOffset;
        const right = left + triangleWidth;
        const bottom = top + triangleHeight;
        return (
          left >= containerRect.left &&
          right <= rightBoundary &&
          top >= containerRect.top &&
          bottom <= mainPaneBottom
        );
      }

      // 마커 숨기기: triangle, text, dashLine 모두 숨김
      function hideMarker(m) {
        m.triangle.style.display = 'none';
        m.text.style.display = 'none';
        if (m.dashLine) m.dashLine.style.display = 'none';
      }

      // 삼각형만 보이기 (텍스트와 dashLine은 숨김)
      function showOnlyTriangle(m, x, y) {
        m.triangle.style.display = 'block';
        setTrianglePosition(m, x, y);
        m.text.style.display = 'none';
        if (m.dashLine) m.dashLine.style.display = 'none';
      }

      // ===================================================================
      const MAX_MARKERS = 75;

      function repositionMarkers() {
        const visibleRange = chart.timeScale().getVisibleRange();
        if (!visibleRange) return;

        const timeScaleWidth = chart.timeScale().width();
        const containerEl = document.getElementById('container');
        const containerRect = containerEl.getBoundingClientRect();
        const priceScaleWidth = chart.priceScale("right")?.width() || 0;
        const rightBoundary = containerRect.right - priceScaleWidth;
        const mainPaneBottom = containerRect.top + chart.panes()[0].getHeight();
        const triangleTipOffset = triangleHeight / 2;
        const textMargin = 10;
        const gap = 2;

        // 현재 보이는 마커 개수 계산
        let visibleCount = 0;
        window.customMarkers.forEach(m => {
          const { x } = getMarkerCoords(m);
          if (x !== null && x >= 0 && x <= timeScaleWidth) visibleCount++;
        });
        const hideMarkers = visibleCount > MAX_MARKERS;

        // MAX_MARKERS 이상이면 삼각형만 그리고 바로 리턴
        if (hideMarkers) {
          window.customMarkers.forEach(m => {
            const { x, y } = getMarkerCoords(m);
            if (x != null && y != null) {
              const left = m.position === 'left' ? x - triangleWidth : x;
              const top = y - triangleTipOffset;
              // 경계 안에 들어올 때만 보이게
              if (
                left >= containerRect.left &&
                left + triangleWidth <= rightBoundary &&
                top >= containerRect.top &&
                top + triangleHeight <= mainPaneBottom
              ) {
                showOnlyTriangle(m, x, y);
              } else {
                hideMarker(m);
              }
            } else {
              hideMarker(m);
            }
          });
          return;
        }

        // ── 일반 처리: visibleMarkers 이하일 때 ─────────────
        // 그룹화를 위한 객체 (같은 time과 position을 갖는 마커들)
        const groups = {};
        window.customMarkers.forEach(m => {
          if (m.time < visibleRange.from || m.time > visibleRange.to) {
            hideMarker(m);
            return;
          }

          const { x, y } = getMarkerCoords(m);
          if (x == null || y == null) {
            hideMarker(m);
            return;
          }

          m._xCoord = x;
          m._yTriangle = y;
          m.triangle.style.display = 'block';
          m.text.style.display = 'block';

          const key = m.time + "_" + m.position;
          if (!groups[key]) groups[key] = [];
          groups[key].push(m);
        });

        // dashLine 업데이트 및 경계 체크
        const canvasEl = containerEl.querySelector('canvas');
        const canvasRect = canvasEl.getBoundingClientRect();
        const parentRect = containerRect;

        window.dashSvg.style.top = `${canvasRect.top - parentRect.top}px`;
        window.dashSvg.style.left = `${canvasRect.left - parentRect.left}px`;
        window.dashSvg.style.width = `${canvasRect.width}px`;
        window.dashSvg.style.height = `${canvasRect.height}px`;
        window.dashSvg.style.overflow = 'hidden';

        const clipWidth = canvasRect.width;
        const clipHeight = canvasRect.height;

        window.customMarkers.forEach(m => {
          if (!m.dashLine) return;

          const x1 = chart.timeScale().timeToCoordinate(m.from_time);
          const x2 = chart.timeScale().timeToCoordinate(m.time);
          const y1 = mainSeries.priceToCoordinate(m.from_price);
          const y2 = mainSeries.priceToCoordinate(m.marker_price);

          if ([x1, x2, y1, y2].some(v => v == null)) {
            m.dashLine.style.display = 'none';
            return;
          }

          m.dashLine.setAttribute('x1', x1);
          m.dashLine.setAttribute('y1', y1);
          m.dashLine.setAttribute('x2', x2);
          m.dashLine.setAttribute('y2', y2);

          const lineOutside =
            Math.max(x1, x2) < 0 ||
            Math.min(x1, x2) > clipWidth ||
            Math.max(y1, y2) < 0 ||
            Math.min(y1, y2) > clipHeight;
          m.dashLine.style.display = lineOutside ? 'none' : 'block';
        });

        // 삼각형 위치 지정 (업데이트된 좌표로 재설정)
        window.customMarkers.forEach(m => {
          if (m.triangle.style.display === 'none') return;
          if (m.position === 'left') {
            m.triangle.style.left = `${m._xCoord - triangleWidth}px`;
            m.triangle.style.top = `${m._yTriangle - triangleTipOffset}px`;
          } else if (m.position === 'right') {
            m.triangle.style.left = `${m._xCoord}px`;
            m.triangle.style.top = `${m._yTriangle - triangleTipOffset}px`;
          }
        });

        // 텍스트 스택 조정 (같은 time/position 그룹끼리)
        for (const key in groups) {
          const group = groups[key];
          if (group.length === 0) continue;
          if (group[0].position === 'left') {
            const baseY = mainSeries.priceToCoordinate(group[0].candleLow) + textMargin;
            let cumulativeOffset = 0;
            group.forEach(m => {
              const textRect = m.text.getBoundingClientRect();
              const newTextTop = baseY + cumulativeOffset;
              m.text.style.left = `${m._xCoord - textRect.width / 2}px`;
              m.text.style.top = `${newTextTop}px`;
              cumulativeOffset += textRect.height + gap;
            });
          } else if (group[0].position === 'right') {
            const baseY = mainSeries.priceToCoordinate(group[0].candleHigh) - textMargin;
            let cumulativeOffset = 0;
            group.forEach(m => {
              const textRect = m.text.getBoundingClientRect();
              const newTextTop = baseY - (cumulativeOffset + textRect.height);
              m.text.style.left = `${m._xCoord - textRect.width / 2}px`;
              m.text.style.top = `${newTextTop}px`;
              cumulativeOffset += textRect.height + gap;
            });
          }
        }

        // 최종 경계 체크: 삼각형/텍스트가 컨테이너 범위를 벗어나면 숨김
        window.customMarkers.forEach(m => {
          if (m.triangle.style.display !== 'none') {
            const triRect = m.triangle.getBoundingClientRect();
            const textRect = m.text.getBoundingClientRect();
            const markerLeft = Math.min(triRect.left, textRect.left);
            const markerRight = Math.max(triRect.right, textRect.right);
            const markerTop = Math.min(triRect.top, textRect.top);
            const markerBottom = Math.max(triRect.bottom, textRect.bottom);

            if (
              markerLeft < containerRect.left ||
              markerRight > rightBoundary ||
              markerTop <= containerRect.top ||
              markerBottom >= mainPaneBottom
            ) {
              hideMarker(m);
            } else if (hideMarkers) {
              hideMarker(m);
            }
          }
        });
      }

      // 실시간 업데이트를 위한 애니메이션 루프
      function updateLoop() {
        repositionMarkers();
        animationFrameId = requestAnimationFrame(updateLoop);
      }
      updateLoop();

      // 마커 데이터(JSON 문자열)를 파싱 후, 마커 생성
      const markerData = JSON.parse('{{ markers }}');
      markerData?.forEach(marker => addCustomMarker(marker));

      // ------------------------------------------------------
      // 날짜 툴팁 생성
      // ------------------------------------------------------
      const tooltip = document.createElement("div");

      // 툴팁 스타일 설정
      tooltip.style.position = "absolute";
      tooltip.style.display = "none";
      tooltip.style.fontWeight = "400"; // 얇은 볼드
      tooltip.style.background = "#363a45";
      tooltip.style.color = "white";
      tooltip.style.padding = "4px 8px";
      tooltip.style.fontSize = "12px";
      tooltip.style.pointerEvents = "none";
      tooltip.style.zIndex = "10000";

      container.appendChild(tooltip);

      // ------------------------------------------------------
      // 특정 페인의 top 위치(픽셀)를 계산하는 헬퍼 함수
      // (pane 0부터 paneIdx-1까지의 높이를 누적)
      // ------------------------------------------------------
      function getPaneTopOffset(paneIdx) {
        const panes = chart.panes();
        let offset = 0;
        for (let i = 0; i < paneIdx; i++) {
          offset += panes[i].getHeight();
        }
        return offset;
      }

      // ------------------------------------------------------
      // 크로스헤어 이동 시 (subscribeCrosshairMove)
      // 1) 하단 툴팁에 날짜 표시
      // 2) 좌상단에 가격/볼륨/지표 데이터 업데이트
      // ------------------------------------------------------
      chart.subscribeCrosshairMove((param) => {
        // crosshair가 차트 밖으로 벗어났을 경우 초기화
        if (!param.time || !param.point) {
          tooltip.style.display = 'none';
          document.getElementById("candleData").innerText = "";
          document.getElementById("mainIndicatorInfo").innerHTML = "";
          Object.values(window.paneIndicatorDivs || {}).forEach(div => div.innerHTML = "");
          return;
        }

        // ------------------------------------------------------
        // 툴팁에 시간/날짜 표시 (UTC 기준 포맷)
        // ------------------------------------------------------
        const date =
          typeof param.time === "string"
            ? new Date(param.time)
            : new Date(param.time * 1000);

        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, "0");
        const day = String(date.getUTCDate()).padStart(2, "0");
        const hours = String(date.getUTCHours()).padStart(2, "0");
        const minutes = String(date.getUTCMinutes()).padStart(2, "0");

        // 요일 (0~6 => 일~토)
        const days = ["일", "월", "화", "수", "목", "금", "토"];
        const dayOfWeek = days[date.getUTCDay()];

        // YYYY-MM-DD HH:MM (요일) 형태로 표시
        const formattedTime = `${year}-${month}-${day} ${hours}:${minutes} (${dayOfWeek})`;
        tooltip.innerHTML = formattedTime;

        // ------------------------------------------------------
        // 툴팁을 X축 기준으로 중앙에 배치 
        // ------------------------------------------------------
        let left = param.point.x;
        const timeScaleWidth = chart.timeScale().width();
        const priceScaleWidth = chart.priceScale("left").width();
        const tooltipWidth = tooltip.offsetWidth || 80;
        const halfTooltipWidth = tooltipWidth / 2;

        // priceScaleWidth: 왼쪽 스케일(없으면 0)에 대한 보정
        left += priceScaleWidth - halfTooltipWidth;

        // 툴팁이 우측으로 삐져나가지 않도록 처리
        left = Math.min(left, priceScaleWidth + timeScaleWidth - tooltipWidth);

        // 툴팁이 좌측으로 삐져나가지 않도록 처리
        left = Math.max(left, priceScaleWidth);

        tooltip.style.left = left + "px";

        // 차트 하단(2px 위)에 위치
        tooltip.style.top = container.clientHeight - tooltip.offsetHeight - 2 + "px";
        tooltip.style.display = "block";

        // ------------------------------------------------------
        // 좌상단 '가격 데이터' 업데이트
        // ------------------------------------------------------

        // 현재 crosshair 위치에 해당하는 캔들 인덱스를 찾음
        let currentIndex = candleStickData.findIndex(
          (item) => item.time === param.time
        );

        // 만약 해당 time 값을 못 찾으면, 마지막 캔들을 사용
        if (currentIndex === -1) {
          currentIndex = candleStickData.length - 1;
        }

        const currentCandle = candleStickData[currentIndex];

        // 전 캔들 종가 대비 등락률(%) 계산
        let percentChange = "";
        if (currentIndex > 0) {
          const previousCandle = candleStickData[currentIndex - 1];
          percentChange = (
            ((currentCandle.close / previousCandle.close) - 1) *
            100
          ).toFixed(2);
        }

        // 등락률 문자열이 존재하면 " (xxx%)" 형태, 없으면 "" 
        const percentString = percentChange ? ` (${percentChange}%)` : "";

        // 시가 < 종가 => 양봉(초록), 반대 => 음봉(빨강) 
        const priceColor =
          currentCandle.close >= currentCandle.open ? "#4caf50" : "#f23645";

        // HTML 태그로 가격/볼륨 정보 생성 (색상 포함)
        const priceInfo = 
          `
            <span class="price-group">  
              <span class="price-label">시가</span><span class="price-value" style="color: ${priceColor}">${currentCandle.open}</span>
            </span>

            <span class="price-group">
              <span class="price-label">고가</span><span class="price-value" style="color: ${priceColor}">${currentCandle.high}</span>
            </span>

            <span class="price-group">
              <span class="price-label">저가</span><span class="price-value" style="color: ${priceColor}">${currentCandle.low}</span>
            </span>

            <span class="price-group">
              <span class="price-label">종가</span><span class="price-value" style="color: ${priceColor}">${currentCandle.close}${percentString}</span>
            </span>

            <span class="price-group">
              <span class="price-label">볼륨</span><span class="price-value" style="color: ${priceColor}">${currentCandle.volume}</span>
            </span>
          `;

        // candleData 영역에 삽입
        document.getElementById("candleData").innerHTML = priceInfo;

        // ------------------------------------------------------
        // 지표 데이터 업데이트
        // ------------------------------------------------------
        // indicatorSeriesInfo: 시리즈별 정보(라인 색, 지표명 등)
        // indicatorData: 실제 시리즈별 (time, value, color) 배열
        // indicatorInfoPerPane: pane별 HTML 텍스트를 임시로 저장할 객체

        const indicatorInfoPerPane = {};

        if (window.indicatorSeriesInfo && window.indicatorData) {
          for (const seriesId in window.indicatorSeriesInfo) {
            const info = window.indicatorSeriesInfo[seriesId];
            const dataArr = window.indicatorData[seriesId];
            let value = "-";
            let valueColor = "#ffffff"; // 기본 흰색

            // 현재 커서의 time에 해당하는 데이터를 찾음
            for (let i = 0; i < dataArr.length; i++) {
              if (dataArr[i].time == param.time) {
                value = dataArr[i].value;

                // 시리즈 유형별(Area, Baseline, Histogram, Line)로 색상 결정
                switch (info.seriesType) {
                  case "Area":
                    // Area: lineColor(또는 기본 흰색)
                    valueColor = info.lineColor || "#ffffff";
                    break;

                  case "Baseline":
                    // Baseline: value가 baseValue보다 크면 topLineColor, 작으면 bottomLineColor
                    if (typeof value === "number" && !isNaN(value)) {
                      if (value > info.baseValue) {
                        valueColor = info.topLineColor || "#ffffff";
                      } else {
                        valueColor = info.bottomLineColor || "#ffffff";
                      }
                    }
                    break;

                  case "Histogram":
                    // Histogram: 각 bar 데이터의 color
                    valueColor = dataArr[i].color || "#ffffff";
                    break;

                  case "Line":
                    // Line: 설정된 lineColor
                    valueColor = info.lineColor || "#ffffff";
                    break;
                }
                break;
              }
            }

            // value가 숫자이면 소수점 precision 자리까지 표시
            if (typeof value === "number" && !isNaN(value)) {
              value = value.toFixed(precision);
            }

            // pane 구분 (0 => 메인 차트, 1 이상 => 별도 페인)
            if (!indicatorInfoPerPane[info.pane]) {
              indicatorInfoPerPane[info.pane] = [];
            }

            // HTML로 감싸서 색상 적용
            const lineHtml = `
                                ${info.name}&nbsp;&nbsp;<span
                                  style="
                                    color: ${valueColor};
                                    position: relative;
                                    display: inline-block;
                                    top: 1px;
                                    margin-top: 1px;">
                                ${value}</span>
                              `;

            indicatorInfoPerPane[info.pane].push(lineHtml);
          }
        }

        // ------------------------------------------------------
        // 메인 차트(오버레이) 지표: pane 0에 표시
        // ------------------------------------------------------
        if (indicatorInfoPerPane[0]) {
          document.getElementById("mainIndicatorInfo").innerHTML =
            indicatorInfoPerPane[0]
              .map((line) => `<div style="margin-bottom:2px;">${line}</div>`)
              .join("");
        }

        // ------------------------------------------------------
        // 추가 페인(1 이상) 지표 정보 표시
        // ------------------------------------------------------
        window.paneIndicatorDivs = window.paneIndicatorDivs || {};
        const paneCount = {{ pane_count }};

        for (let pane = 1; pane <= paneCount; pane++) {
          // 아직 해당 pane용 DIV가 없다면 생성
          if (!window.paneIndicatorDivs[pane]) {
            const div = document.createElement("div");
            div.id = "indicatorInfo_pane_" + pane;
            div.style.position = "absolute";
            div.style.left = "4px";
            div.style.top = getPaneTopOffset(pane) + "px"; // 실제 높이를 기반으로 계산
            div.style.marginTop = "5px";
            div.style.zIndex = "1000";
            div.style.background = "rgba(15,15,15,0)";
            div.style.color = "white";
            div.style.padding = "8px 12px";
            div.style.borderRadius = "4px";
            div.style.fontFamily = "sans-serif";
            div.style.lineHeight = "1.4";
            div.style.fontSize = "14px";

            document
              .getElementById("container")
              .appendChild(div);

            window.paneIndicatorDivs[pane] = div;
          }

          // indicatorInfoPerPane[pane]에 데이터가 있으면 표시, 없으면 빈 문자열
          window.paneIndicatorDivs[pane].innerHTML = indicatorInfoPerPane[pane]
            ? indicatorInfoPerPane[pane]
                .map((line) => `<div style="margin-bottom:2px;">${line}</div>`)
                .join("")
            : "";
        }
      });

      // ------------------------------------------------------
      // 시간 슬라이더 생성
      // ------------------------------------------------------
      const slider = document.getElementById("timeSlider");

      function updateSliderLayout() {
        const lr = chart.timeScale().getVisibleLogicalRange();
        if (!lr) return;
        const visibleCount = lr.to - lr.from;

        const leftWidth = chart.priceScale("left").width();
        const rightWidth = chart.priceScale("right").width();
        const timeWidth = chart.timeScale().width();

        // 슬라이더 범위: 0 ~ (전체 바 개수 - 1)
        slider.min = 0;
        slider.max = candleStickData.length - 1;
        slider.style.left = `${leftWidth}px`;
        slider.style.right = `${rightWidth + 3}px`;
        slider.style.width = `${timeWidth - 3}px`;

        // 현재 보이는 logical range(from~to)의 중앙값을 계산해서 slider.value에 반영
        const centerIndex = Math.round((lr.from + lr.to) / 2);
        slider.value = Math.min(Math.max(centerIndex, slider.min), slider.max);
      }

      // 초기 세팅: 우측 끝 (Max)
      updateSliderLayout();
      slider.value = candleStickData.length - 1; // 기본: 마지막 바를 중앙에

      // 리사이즈·줌 변경 시 레이아웃만 갱신
      window.addEventListener("resize", updateSliderLayout);
      chart.timeScale().subscribeVisibleLogicalRangeChange(updateSliderLayout);

      // 슬라이더 이동 시 차트 패닝만
      slider.addEventListener("input", () => {
        const centerIndex = Number(slider.value);
        const lr = chart.timeScale().getVisibleLogicalRange();
        const visibleCount = lr.to - lr.from;
        const half = visibleCount / 2;

        chart.timeScale().setVisibleLogicalRange({
          from: centerIndex - half,
          to: centerIndex + half,
        });
      });

      const sliderDateEl = document.getElementById('sliderDate');

      function updateSliderDate() {
        const idx = Number(slider.value);
        const bar = candleStickData[idx];
        if (!bar) return;

        // 날짜 포맷 생성 (기존 코드 그대로)
        const date = new Date(typeof bar.time === 'string' ? bar.time : bar.time * 1000);
        const days = ["일","월","화","수","목","금","토"];
        const formatted = `${date.getUTCFullYear()}-${String(date.getUTCMonth()+1).padStart(2,'0')}-${String(date.getUTCDate()).padStart(2,'0')} ${String(date.getUTCHours()).padStart(2,'0')}:${String(date.getUTCMinutes()).padStart(2,'0')} (${days[date.getUTCDay()]})`;
        sliderDateEl.innerText = formatted;

        const containerRect = document.getElementById('container').getBoundingClientRect();
        const sliderRect    = slider.getBoundingClientRect();

        const percent = (idx - slider.min) / (slider.max - slider.min);
        const thumbWidth = 120; // CSS에서 지정한 thumb 너비
        // track 전체 너비에서 thumb 너비를 뺀 만큼 이동 → + thumb 반절(offset)
        const x = sliderRect.left - containerRect.left + percent * (sliderRect.width - thumbWidth) + thumbWidth / 2;

        sliderDateEl.style.left = `${x}px`;
      }

      // 초기 표시
      updateSliderDate();

      // 실시간 업데이트
      slider.addEventListener('input', updateSliderDate);
      
      // 날짜 업데이트 + 보이기
      slider.addEventListener('input', () => {
        updateSliderDate();
        sliderDateEl.style.display = 'block';
      });

      // 슬라이더 놓을 때 숨기기
      slider.addEventListener('mouseup', () => sliderDateEl.style.display = 'none');
      slider.addEventListener('touchend', () => sliderDateEl.style.display = 'none');

      // 줌인아웃 시 슬라이더 위치 업데이트
      chart.timeScale().subscribeVisibleLogicalRangeChange(updateSliderDate);
      window.addEventListener('resize', updateSliderDate);

    </script>
  </body>
</html>
